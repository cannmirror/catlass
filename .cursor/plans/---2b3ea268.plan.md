<!-- 2b3ea268-f0a5-4ab7-91d8-e86028b6cc46 912f4a79-cef4-4f70-8b17-99d584e3e252 -->
# 实现 TopologicalVisitor 并接入 34matmuladd_topo

## 变更范围

- 新增: `include/catlass/epilogue/fusion/topological_visitor.hpp`
- 编辑: `include/catlass/epilogue/fusion/fusion.hpp`（聚合头增加新头文件）
- 编辑: `examples/34_matmul_add_topo/matmul_add_topo.cpp`（将 TreeVisitor 切换为 TopologicalVisitor）

## 设计要点

- `TopologicalVisitor<EdgeTuple, Ops...>` 继承现有 `VisitorImpl<Ops...>`，重用参数打包、工作区大小、可实现性检查等逻辑。
- 在其内部 `Callbacks` 中提供统一的 `visit(tileOffset, localTileOffset, tileShape, calCount, stage, ...)`：
  - 以 R = sizeof...(Ops) 为节点数，最后一个节点（索引 R-1）作为“根”（最终算子）。
  - 对任意节点 i，读取 `Edges_i = get<i>(EdgeTuple{})`（类型为 `tla::seq<child...>`），递归调用子节点 `visit(...)` 获取输出，以该序列提供的顺序作为输入，调用第 i 个回调的 `visit(...)`。
  - 分阶段（LOAD/COMPUTE/STORE）行为由各算子自身回调内部自行判别，拓扑调度仅负责调用顺序与参数传递。
- 不强制进行“统一计算精度”的中间结果转换（避免额外 UB 申请）；如需跨类型组合，仍通过现有 `VisitorCast<...>` 节点自行插入（与当前框架一致）。

## 示例接入（34_matmul_add_topo）

- 将原先的树形 EVT 定义替换为拓扑 EVT，按节点顺序 `[AccLoad, AuxLoad, Compute(Plus), Store]`，并定义边：
  - `AccLoad`: 无子节点
  - `AuxLoad`: 无子节点
  - `Compute`: 依赖 `[AccLoad, AuxLoad]`
  - `Store`: 依赖 `[Compute]`
- 关键片段（仅示意，新代码）：
```cpp
// 定义依赖拓扑
using Edges = tla::tuple<
    tla::seq<>,      // 0: AccLoad
    tla::seq<>,      // 1: AuxLoad
    tla::seq<0, 1>,  // 2: Compute(Acc, Aux)
    tla::seq<2>      // 3: Store(Compute)
>;

using EVT = Epilogue::Fusion::TopologicalVisitor<
    Edges,
    Epilogue::Fusion::VisitorAccLoad<half>,
    Epilogue::Fusion::VisitorAuxLoad<half, LayoutC>,
    Epilogue::Fusion::VisitorCompute<Epilogue::Fusion::Plus, half>,
    Epilogue::Fusion::VisitorAuxStore<half, LayoutC>
>;

// 注意 evt_args 顺序与 Ops... 一致：AccLoad, AuxLoad, Compute, Store
typename EVT::Arguments evt_args{
    Epilogue::Fusion::VisitorAccLoad<half>::Arguments{},
    Epilogue::Fusion::VisitorAuxLoad<half, LayoutC>::Arguments{deviceX, layoutD},
    Epilogue::Fusion::VisitorCompute<Epilogue::Fusion::Plus, half>::Arguments{},
    Epilogue::Fusion::VisitorAuxStore<half, LayoutC>::Arguments{deviceD, layoutD}
};
```

- 其余代码（BlockEpilogue、MatmulEvt、DeviceGemm 等）保持不变。

## 构建与验证

- 在 `fusion.hpp` 中增加 `#include "catlass/epilogue/fusion/topological_visitor.hpp"`。
- 进入 `examples/34_matmul_add_topo/` 执行 `bash run.sh` 完成清理、编译与运行；检查“Compare success.”。

## 回滚与风险

- 若编译错误集中于模板推断或 `EVT::Arguments` 顺序不匹配，按报错调整 `Edges` 或 `Ops...` 顺序保持一致。
- 若将来需要统一计算精度，可后续扩展 `TopologicalVisitor` 在回调层面增加可选的中间转换缓冲，但当前示例无需。

### To-dos

- [ ] 新增 topological_visitor.hpp 并实现 TopologicalVisitor<EdgeTuple, Ops...>
- [ ] 在 fusion.hpp 中加入 topological_visitor.hpp 头文件
- [ ] 修改 34_matmul_add_topo.cpp 使用 TopologicalVisitor 与 Edges
- [ ] 运行 examples/34_matmul_add_topo/run.sh 验证 Compare success